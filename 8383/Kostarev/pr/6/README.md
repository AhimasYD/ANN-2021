# Практическое задание 6
Выполнил Костарев Кирилл, гр. 8383
## Постановка задачи
Необходимо построить сверточную нейронную сеть, которая будет классифицировать черно-белые изображения с простыми геометрическими фигурами на них.

К каждому варианту прилагается код, который генерирует изображения.

Для генерации данных необходимо вызвать функцию gen_data, которая возвращает два тензора:
1. Тензор с изображениями ранга 3
2. Тензор с метками классов

Обратите внимание:
- Выборки не перемешаны, то есть наблюдения классов идут по порядку
- Классы характеризуются строковой меткой
- Выборка изначально не разбита на обучающую, контрольную и тестовую
- Скачивать необходимо оба файла. Подключать файл, который начинается с var (в нем и находится функция gen_data)

### Вариант 4
Классификация изображений с крестом или с линией (может быть горизонтальной или вертикальной)

## Выполнение работы
С помощью функции gen_data были сгенерированы данные. Кодирование меток было произведено с помощью LabelEncoder библиотеки sklearn. С помощью функции train_test_split этой же библиотеки данные в случайном порядке были разбиты на тренировочные и тестовые.

Далее была определена следующая структура модели:
1. Input
2. Convolution2D: 
    - функция активации 'relu' 
    - размер ядра свертки 5x5
3. Convolution2D (с теми же параметрами)
4. MaxPooling2D
    - размер подвыборки 2x2
5. Dropout
    - вероятность: 0.25
6. Flatten
7. Dense
    - функция активации 'relu'
8. Dropout
    - вероятность: 0.5
9. Dense
    - функция активации 'sigmoid'

Параметры модели:
- Функция ошибки: бинарная кроссэнтропия
- Оптимизация: Adam
- Метрика: точность
- Количество эпох: 10
- Размер подвыборки: 32

## Демонстрация работы модели
    Epoch 1/10
    10/10 [==============================] - 4s 365ms/step - loss: 0.6739 - accuracy: 0.5370 - val_loss: 0.6705 - val_accuracy: 0.5000

    Epoch 2/10
    10/10 [==============================] - 3s 266ms/step - loss: 0.5252 - accuracy: 0.7404 - val_loss: 0.5577 - val_accuracy: 0.6765

    Epoch 3/10
    10/10 [==============================] - 3s 269ms/step - loss: 0.3522 - accuracy: 0.9042 - val_loss: 0.3913 - val_accuracy: 0.7647

    Epoch 4/10
    10/10 [==============================] - 3s 276ms/step - loss: 0.1329 - accuracy: 0.9698 - val_loss: 0.2208 - val_accuracy: 0.9706

    Epoch 5/10
    10/10 [==============================] - 3s 294ms/step - loss: 0.0616 - accuracy: 0.9778 - val_loss: 0.2370 - val_accuracy: 0.9118

    Epoch 6/10
    10/10 [==============================] - 3s 289ms/step - loss: 0.0309 - accuracy: 1.0000 - val_loss: 0.1561 - val_accuracy: 0.9706

    Epoch 7/10
    10/10 [==============================] - 3s 291ms/step - loss: 0.0082 - accuracy: 1.0000 - val_loss: 0.0875 - val_accuracy: 0.9706

    Epoch 8/10
    10/10 [==============================] - 3s 296ms/step - loss: 0.0029 - accuracy: 1.0000 - val_loss: 0.0819 - val_accuracy: 0.9706

    Epoch 9/10
    10/10 [==============================] - 3s 306ms/step - loss: 0.0013 - accuracy: 1.0000 - val_loss: 0.0716 - val_accuracy: 0.9706

    Epoch 10/10
    10/10 [==============================] - 3s 304ms/step - loss: 8.8203e-04 - accuracy: 1.0000 - val_loss: 0.0727 - val_accuracy: 0.9706

    6/6 [==============================] - 0s 63ms/step - loss: 0.0233 - accuracy: 0.9879

Можем видеть, что точность на тренировочных данных ссоставила 100%, на тестовых 97%, а на проверочных данных 98,7%.

Таким образом, модель работает корректно.
